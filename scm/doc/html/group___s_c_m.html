<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>GMTB Single Column Model: GMTB Single Column Model</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="dtc_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GMTB Single Column Model
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___s_c_m.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<div class="title">GMTB Single Column Model</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__forcing"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__forcing.html">gmtb_scm_forcing</a></td></tr>
<tr class="memdesc:group__forcing"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains subroutines to handle the SCM forcing &ndash; interpolating in space and time, etc. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__input"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__input.html">gmtb_scm_input</a></td></tr>
<tr class="memdesc:group__input"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains input-related subroutines &ndash; reading in model configuration from file or the command line and reading in the case initial conditions and forcing; also contains reference profile input (temporarily hard-coded). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__output"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__output.html">gmtb_scm_output</a></td></tr>
<tr class="memdesc:group__output"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains output-related subroutines. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__setup"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__setup.html">gmtb_scm_setup</a></td></tr>
<tr class="memdesc:group__setup"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains subroutines to initialize the SCM, including setting the atmospheric state, interpolating initial conditions to the model grid, and patching in a reference sounding above the provided initial conditions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__time__integration"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__time__integration.html">gmtb_scm_time_integration</a></td></tr>
<tr class="memdesc:group__time__integration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains subroutines to handle the SCM time stepping. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__utils"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html">gmtb_scm_utils</a></td></tr>
<tr class="memdesc:group__utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains miscellaneous helper subroutines. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__vgrid"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vgrid.html">gmtb_scm_vgrid</a></td></tr>
<tr class="memdesc:group__vgrid"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the vertical grid setup routines. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2e62134ed0a98729f7dbc2d5753e547"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_m.html#gaf2e62134ed0a98729f7dbc2d5753e547">gmtb_scm_main::gmtb_scm_main_sub</a> ()</td></tr>
<tr class="memdesc:gaf2e62134ed0a98729f7dbc2d5753e547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main SCM program.  <a href="group___s_c_m.html#gaf2e62134ed0a98729f7dbc2d5753e547">More...</a><br /></td></tr>
<tr class="separator:gaf2e62134ed0a98729f7dbc2d5753e547"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function/Subroutine Documentation</h2>
<a class="anchor" id="gaf2e62134ed0a98729f7dbc2d5753e547"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine gmtb_scm_main::gmtb_scm_main_sub </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main SCM program. </p>
<dl class="section author"><dt>Author</dt><dd>Grant J. Firl </dd></dl>
<dl class="section date"><dt>Date</dt><dd>March-June 2016</dd></dl>
<p>The prototype GMTB SCM can be thought of as an update to the existing GFS SCM to 1) use the NGGPS Interoperable Physics Driver (IPD) (and to keep up with its development) and 2) have the capability to run GCSS-style idealized cases. Its initialization draws heavily from the standalone IPD developed by Patrick Tripp at NOAA EMC. Many of the algorithms are heavily influenced by the original GFS SCM, and clues for implementation were also gleaned from how the IPD is implemented (called) in the GSM. The standalone driver demonstrated how to use the nuopc_physics module to calculate tendencies due to radiation and the rest of the physics suite once, including initialization. It uses 8 columns and it initializes GFS state variables from unformatted binary output files that are (I believe) generated from a GFS model run.</p>
<p>The SCM prototype differs from the standalone driver in several important ways. First, although the state arrays will maintain a "horizontal" dimension (be capable of representing more than one column), the code is designed to use a single column. Second, in order to avoid becoming a GFS-only SCM, input is achieved through host-model agnostic netCDF files. In addition, variables needed to initialize or configure the physics suite are obtained through external namelist files to avoid using GFS output files. Third, the model will have the ability to use different vertical grids and coordinates as well as different time-stepping schemes (initial capability follows the GFS, however). Fourth, the SCM includes functionality to advance through time, calling physics repeatedly, and to replace dynamics/advection with specified large-scale forcing. </p>
<h1><a class="anchor" id="alg"></a>
Main Algorithm</h1>
<h2><a class="anchor" id="modules"></a>
Load the necessary modules for the GTMB SCM.</h2>
<ul>
<li>Load the GMTB SCM modules called from the main program.</li>
<li>Load modules that are needed for using the interoperable physics driver (IPD); includes derived data types (DDTs) and subroutines that are called to drive the physics suite.</li>
<li>Load the modules that are needed for the GFS physics suite</li>
</ul>
<h2><a class="anchor" id="var_dec"></a>
Variable Declarations</h2>
<ul>
<li>Define the variables necessary for the SCM infrastructure.</li>
<li>Define the case-specific initialization and forcing variables.</li>
<li>Define the reference profile variables.</li>
<li>Define the SCM state variables; variables with appended "i" are interface; variables with appended "l" are layer-centered.<ul>
<li>index order for grid is (horizontal, vertical);</li>
<li>index order for state variables is (horizontal, vertical, timesteps);</li>
<li>index order for tracer is (horizontal, vertical, tracer_index, timesteps)</li>
</ul>
</li>
<li>Define forcing-related variables (indexing is (horizontal, vertical)).</li>
<li>Define ozone forcing variables (the input forcing terms reside on their own (latitude, levels, time) grid and have 'pl_coeff' terms)</li>
<li>Define h2o forcing variables (the input forcing terms reside on their own (latitude, levels, time) grid and have 'h2o_coeff' terms)</li>
<li>Define GFS-related grid coefficients.</li>
<li>Define variables from the standalone driver.<ul>
<li>Define namelist variables (see namelists in model_config).</li>
<li>Define DDT variables used in nuopc_physics.F90</li>
<li>The remaining varialbes are defined in the DDT sections of nuopc_physics.F90</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="init"></a>
SCM Initialization</h2>
<ul>
<li>Define the namelists that get read in to configure the GFS physics suite. There are separate namelists for GFS physics (general), GFS radiation, GFS surface scheme, GFS clouds, and miscellaneous GFS variables (GFS_tbd)</li>
<li>Call get_config in <a class="el" href="group__input.html">gmtb_scm_input</a> to fetch the basic model configuration variables (from file or command line)</li>
<li>Call get_case_init in <a class="el" href="group__input.html">gmtb_scm_input</a> to read and return the case input data.</li>
<li>Call get_reference_profile in <a class="el" href="group__input.html">gmtb_scm_input</a> to return a reference profile to use above the case profile.</li>
<li>Set up the vertical grid and time-integration scheme based on the host model choice.<ul>
<li>Call get_GFS_grid in <a class="el" href="group__vgrid.html">gmtb_scm_vgrid</a> to read in the necessary coefficients and calculate the pressure-related variables on the grid.</li>
<li>Exit if an unsupported number of levels is specified or the file with grid coefficients cannot be opened.</li>
<li>Set the number of time levels needed to be stored in memory based on the choice of time-stepping scheme for the forcing</li>
</ul>
</li>
<li>Once all dimensions are known, allocate the necessary arrays.</li>
<li><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>state_tracer and temp_tracer should use a variable for dimension 3. </dd></dl>
</li>
<li>Read in namelists for GFS model control variables rather than read a GFS output file as in the standalone driver.</li>
<li><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>These namelists are GFS physics-specific. This should probably be placed in the host model switch above. </dd></dl>
</li>
<li><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>The physics and dynamics timesteps are equal in the SCM. This may need to be changed in the future. </dd></dl>
</li>
<li>Since some GFS initialization routines look for datasets in the working directory, use a system call to copy runtime data into the working directory.</li>
<li>Call set_state in <a class="el" href="group__setup.html">gmtb_scm_setup</a> to interpolate the case input data to the model grid and patch in the reference sounding above the case data as necessary.</li>
<li>Initialize the model elapsed time and model time step iteration counter.</li>
<li>Call interpolate_forcing in <a class="el" href="group__forcing.html">gmtb_scm_forcing</a> to interpolate the input forcing to the model grid and model time.</li>
<li><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>need to convert w_ls to omega and pass it into state_fldin (is pointer) </dd></dl>
</li>
<li>Put initial date (idate) into idat format for rad_update. (Is this needed? Done in nuopc_phys_init...)</li>
<li>Set jdat (current date) to idat</li>
<li>Set timesteps for longwave and shortwave radiation.</li>
<li>Set the lmfshal and lmfdeep2 flags as done in gloopr (with comment: "set up parameters for Xu &amp; Randall's cloudiness computation")</li>
<li>Initialize the model time step.</li>
<li>Initialize the longwave/shortwave radiation flags to True.</li>
<li>Convert input latitude/longitude to radians and calculate sin and cos of latitude.</li>
<li><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>Check that solhr is initialized correctly. </dd></dl>
</li>
<li>Initialize physics substep to 1, since physics time step = dynamics time step and there are no substeps.</li>
<li>Initialize a random number array needed for RAS or old SAS</li>
<li>Call ras_init if RAS is the chosen convection scheme.<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>Not tested yet. </dd></dl>
</li>
<li><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>hprim_v is an array of surface-related variables that are geographic location dependent that are used in the gravity wave drag parameterization. in Fletcher's SCM, these are read in; presumably generated with outside scripts/code based on an orography dataset and a given location. These have no influence on maritime cases, but will need to be addressed for land cases. </dd></dl>
</li>
<li><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>Need to understand what this (adjtrc) does... </dd></dl>
</li>
<li>Call output_init in <a class="el" href="group__output.html">gmtb_scm_output</a> to create and initialize the output file.</li>
<li>Write out the initial profiles and forcing.</li>
</ul>
<h3><a class="anchor" id="standalone"></a>
The following code is mostly copied from the NUOPC standalone driver.</h3>
<ul>
<li>The "*_readin" subroutines in the standalone driver are not used in the SCM since the variables are initialized in another way. Similarly, the "*_saveout" routines are not called since the SCM is not being used for regression testing.</li>
<li>Call nuopc_phys_init in nuopc_physics.F90.<ul>
<li>This routine initializes idat, fills in mdl_parm DDT, calls gfuncphys (funcphys.f), rad_initialize (rad_initialize.f), and set_soilveg (set_soilveg.f)</li>
</ul>
</li>
<li>Set deltim = 0.5*dt for first forward time step.</li>
<li>Call the "setrad" methods of the NUOPC DDTs in preparation for nuopc_rad_update and nuopc_rad_run.<ul>
<li>The dynamic_parameters DDT is the only DDT that has mostly non-pointers. This setrad routine must be called before nuopc_rad_update and nuopc_rad_run if the underlying parameters have changed.</li>
<li>For the first time step, the state_fields_in DDT points to the filtered values.</li>
</ul>
</li>
<li><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>vvl is initialized to zero, but should be omega converted from large-scale w forcing. </dd></dl>
</li>
<li>Call nuopc_rad_update from nuopc_physics.F90. This is a wrapper to the radupdate found in grrad.f used to "update time-sensitive data used by radiation" code</li>
<li>Call nuopc_rad_run from nuopc_physics.F90. This is a wrapper to the grrad subroutine in grrad.f that is used to "set up and invoke main radiation calls."</li>
<li><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>Calling dyn_parmsetphys resets slag, sdec, cdec to 0; need to call nuopc_rad_update again? -no way to get these values from dyn_parm (private) </dd></dl>
</li>
<li>Call the "setphys" methods of the NUOPC DDTs in preparation for the nuopc_phys_run call.<ul>
<li>The state_fields_in DDT is filled with the time-filtered values of the state variables.</li>
<li>For the leapfrog scheme, the state_fields_out DDT is filled with the unfiltered values of the state variables. The nuopc_phys_run call updates the unfiltered state variables.</li>
</ul>
</li>
<li>Call nuopc_phys_run from nuopc_physics.F90. This is simply a wrapper to gbphys which is the GFS atmospheric physics driver routine.</li>
</ul>
<h2><a class="anchor" id="time_loop"></a>
Time Loop</h2>
<h3><a class="anchor" id="time_loop_description"></a>
Description</h3>
<p>The filtered leapfrog scheme can be represented as follows: </p><p class="formulaDsp">
\[ \frac{x^{\tau + 1} - \overline{x^{\tau - 1}}}{2\Delta t}=F^\tau \]
</p>
<p> where \(x^{\tau + 1}\) is the value of variable \(x\) at time \(\tau + 1\), \(\overline{x^{\tau - 1}}\) is its filtered value at time \(\tau - 1\), \(\Delta t\) is the time step, and \(F^\tau\) is the collection of processes that change \(x\) at time \(\tau\). The Robert-Asselin filtered value of \(x\) is given by </p><p class="formulaDsp">
\[ \overline{x^\tau}=(1-c)x^\tau + 0.5c\left(x^{\tau +1} + \overline{x^{\tau - 1}}\right) \]
</p>
<p> where \(c\) is the filtering constant. This scheme is implemented in the code as follows:</p><ul>
<li>For the current time step (going to time \(\tau + 1\)), we have available at the beginning of the time step the filtered value \(\overline{x^{\tau-1}}\) and the unfiltered value \(x^\tau\). These are represented by state_x(:,:,1) and state_x(:,:,2) in the code, respectively.</li>
<li>At the beginning of the time step, these values are saved in a temporary array for use in the filtering step later.</li>
<li>In the do_time_step routine, nuopc_rad_run uses state_x(:,:,1) (or \(\overline{x^{\tau -1}}\)) as input to calculate the heating rate at time \(\tau\).</li>
<li>In the routine apply_forcing_leapfrog (in <a class="el" href="group__forcing.html">gmtb_scm_forcing</a>), two things happen:<ol type="1">
<li>Tendencies of the state variables due to the forcing are calculated for time \(\tau\) ( \(F^\tau\) above).</li>
<li>The state variables are stepped forward in time using <p class="formulaDsp">
\[ x^{\tau+1}=\overline{x^{\tau -1}} + 2\Delta tF^\tau \]
</p>
 In the code, state_x(:,:,1) is simply updated. This variable is pointed to by the state_fields_in NUOPC DDT and is used as input for the physics call. At this point in the code, this variable no longer represents the filtered values from the previous time step, but the unfiltered state variables after their change due to the forcing and before their changes due to the physics.</li>
</ol>
</li>
<li>During the call to nuopc_phys_run, state_x(:,:,1) is used as the starting point for the state variable and its unfiltered value is updated by the physics and stored in state_x(:,:,2) (which state_fields_out points to). This is considered \(x^{\tau +1}\).</li>
<li>Finally, using \(x^{\tau +1}\) just calculated, and the saved values of \(\overline{x^{\tau-1}}\) and \(x^\tau\), the filtered value \(\overline{x^\tau}\) is calculated by the subroutine filter in <a class="el" href="group__time__integration.html">gmtb_scm_time_integration</a> to be used in the next iteration.</li>
</ul>
<h3><a class="anchor" id="time_loop_algorithm"></a>
Algorithm</h3>
<ul>
<li>Convert various calling frequencies to time step numbers.</li>
<li>Set all time steps equal to the "master" SCM time step</li>
<li>Update dyn_parm DDT with new deltim.</li>
<li>Based on the time-integration method chosen, start the model time loop. Currently, only filtered-leapfrog is implemented.</li>
<li>Start the main time loop.<ul>
<li>Calculate the elapsed model time.</li>
<li>Save previously unfiltered state as temporary for use in the time filter.</li>
<li>Call interpolate_forcing from <a class="el" href="group__forcing.html">gmtb_scm_forcing</a> to interpolate the forcing terms to the model grid and time.</li>
<li>Update the pressure (and related variables) on the grid levels since some cases have a time-dependent surface pressure.</li>
<li>Recalculate sin and cos of latitude since xlon and xlat are time-dependent for some cases. (Column is moving in geographic space)</li>
<li>Before the time step is executed, perform various operations that are found in GLOOPR and GLOOPB before the physics time steps are executed in the GSM.<ul>
<li>GLOOPR code:<ul>
<li>Determine if SW, LW radiation needs to be called and set logical flags.</li>
<li>Update jdat (yr, mon, day, t-zone, hr, min, sec, mil-sec) given the elapsed model time and the initial time.</li>
<li>Set up random numbers for subgrid cloudiness in radiation</li>
<li>Grab variables from "3D arrays saved for restart", calculate minimum large ice fraction ?</li>
<li><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>Go back through GLOOPR to determine what needs to be included here. </dd></dl>
</li>
</ul>
</li>
<li>GLOOPB code:<ul>
<li>Set up random number array needed for RAS and old SAS (should probably only do this if these schemes are active)</li>
<li>Set geopotential and exner functions to zero to force gbphys to recalculate? Set maximum depth of shallow convection.</li>
<li>Zero out convective scheme quantities before the call to gbphys.</li>
<li>Zero out "temperature change due to radiative heating per time step (K)" before call to gbphys.</li>
<li>Zero out "mass change due to moisture variation" before call to gbphys.</li>
<li>Update dynparm physics parameters before call to gbphys.</li>
</ul>
</li>
</ul>
</li>
<li>Update dynparm radiation parameters before call to grrad. (should this only be called on a radiation time step?)</li>
<li>Call do_time_step in <a class="el" href="group__time__integration.html">gmtb_scm_time_integration</a>. This routine calls nuopc_rad_update and nuopc_rad_run (if necessary), apply_forcing_leapfrog from <a class="el" href="group__forcing.html">gmtb_scm_forcing</a>, and nuopc_phys_run. Each updates var(:,:,2), or the unfiltered values of state variables.</li>
<li>Call filter in <a class="el" href="group__time__integration.html">gmtb_scm_time_integration</a> to perform the Asselin time filtering of the state variables.</li>
</ul>
</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd>tracers besides water vapor do not need to be filtered (is this right?) </dd></dl>
<ul>
<li>Execute code that is found in GLOOPR, GLOOPB after the time step is executed.<ul>
<li>The following code is from GLOOPR after the call to radiation. Since the calls to radiation and the rest of the physics in GSM are separate, this code might need to be executed before the call to nuopc_phys_run (gbphys), so I'm not sure if it is OK to put here...</li>
<li>Set some variables from the radiation output variables.</li>
</ul>
</li>
<li>Write output (snapshot of filtered state variables) on the output frequency by calling output_append from <a class="el" href="group__output.html">gmtb_scm_output</a>.</li>
</ul>
<h2><a class="anchor" id="clean_up"></a>
Clean Up</h2>
<ul>
<li>Finally, clean up the data copied to the working directory.</li>
</ul>

<p>Definition at line <a class="el" href="gmtb__scm_8f90_source.html#l00031">31</a> of file <a class="el" href="gmtb__scm_8f90_source.html">gmtb_scm.f90</a>.</p>

<p>References <a class="el" href="gmtb__scm__vgrid_8f90_source.html#l00119">gmtb_scm_vgrid::calc_gfs_pres_and_exner()</a>, <a class="el" href="gmtb__scm__utils_8f90_source.html#l00024">gmtb_scm_utils::copy_data_to_working_dir()</a>, <a class="el" href="gmtb__scm__time__integration_8f90_source.html#l00054">gmtb_scm_time_integration::do_time_step()</a>, <a class="el" href="gmtb__scm__time__integration_8f90_source.html#l00022">gmtb_scm_time_integration::filter()</a>, <a class="el" href="gmtb__scm__input_8f90_source.html#l00168">gmtb_scm_input::get_case_init()</a>, <a class="el" href="gmtb__scm__input_8f90_source.html#l00028">gmtb_scm_input::get_config_nml()</a>, <a class="el" href="gmtb__scm__vgrid_8f90_source.html#l00025">gmtb_scm_vgrid::get_gfs_vgrid()</a>, <a class="el" href="gmtb__scm__input_8f90_source.html#l00323">gmtb_scm_input::get_reference_profile()</a>, <a class="el" href="gmtb__scm__forcing_8f90_source.html#l00028">gmtb_scm_forcing::interpolate_forcing()</a>, <a class="el" href="gmtb__scm__output_8f90_source.html#l00175">gmtb_scm_output::output_append()</a>, <a class="el" href="gmtb__scm__output_8f90_source.html#l00022">gmtb_scm_output::output_init()</a>, <a class="el" href="gmtb__scm__utils_8f90_source.html#l00033">gmtb_scm_utils::remove_data_from_working_dir()</a>, and <a class="el" href="gmtb__scm__setup_8f90_source.html#l00026">gmtb_scm_setup::set_state()</a>.</p>

<p>Referenced by <a class="el" href="gmtb__scm_8f90_source.html#l01270">gmtb_scm()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
